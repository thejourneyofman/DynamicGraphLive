#!/usr/bin/python
# -*- coding: utf-8 -*-

# Copyright (c) 2019 Chao (Chase) Xu
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

"""Module to generate a dynamic graph with its edge degrees and cluster sizes
that follow a power law distribution.
"""

import random
import numpy as np
import scipy.stats
from collections import deque

def power_law(xmin, xmax):
    u"""Returns a scipy.stats._distn_infrastructure.rv_sample object
        :param xmin: the min value of in the sample
        :param xmax: the max value of in the sample
        it generate the probabilidy of the value in range of [xmin, xman]
        following a powerlaw distrubution
    """
    y = np.arange(1, xmax + 1, dtype='float32')
    prob_mass_func =  1/y**xmin
    prob_mass_func /= prob_mass_func.sum()
    return scipy.stats.rv_discrete(values=(range(1, xmax + 1), prob_mass_func))

class GraphNode():
    u"""Returns a class of Node in the graph.
       :param label: the name of the node. Not used in this program
       :param # add param for future use
    """
    def __init__(self, label):
        self.label = label

    def setNeighbours(self, neighbours):
        self.neighbours = neighbours

    def setEdgeDegree(self, degree):
        self.edgedegree = degree

    def getNeighbours(self):
        return self.neighbours

    def getEdgeDegree(self):
        return self.edgedegree

    def is_connected(self):
        return len(self.neighbours) > 0


class ProbGraph():
    u"""Returns a class of processed graph following a power-law rule of edge
        degrees for every node and size of components based on the node numbers,
        max edge numbers and special curves pattern.
       :param node_num: totally generated nodes num.
       :param edge_num: max allowed edge numbers generating the graph.
       :param gamma: It is a parameter of kurtosis for the distribution of edge
        degrees or cluster size that follows a power-law rules. If it is greater,
        the distribution of connected components will have a higher kurtosis.
       Conversely, the distribution of edges degrees will have a higher kurtosis.
       :param copy: If it is True, ProbGraph can be generated by add nodes list
       and a edge list directly.
       If it is False, ProGraph will be generated from scratch.
       """
    def __init__(self, node_num, edge_num, gamma = 3, copy = False):
        if not copy:
            self.V = list(range(node_num))
            self.E = []
            self.temp_component = []
            self.connected_nodes = []
            self.connected_components = []
            self.gamma = gamma
            self.neighbours = {}
            self.visited = {}
            self.source = gamma
            self.isolated_nodes = []
            self.copy = copy

            #############################
            # Do the initialization
            #############################
            self._initialize(node_num)
            self._createEdges(edge_num)
            self.updateComponents()

        else:
            self.V = []
            self.E = []
            self.temp_component = []
            self.connected_nodes = []
            self.connected_components = []
            self.gamma = gamma
            self.neighbours = {}
            self.visited = {}
            self.source = gamma
            self.isolated_nodes = []
            self.copy = copy

    def _initialize(self, node_num):
        u"""Generate a full connected small graph using BA model.
            And also initialize other parameters for first use.
            :param node_num: the total number of the nodes.
        """
        if self.copy:
            return
        for v in list(range(node_num)):
            self.neighbours[v] = []
            self.visited[v] = 0
        init_nodes = list(range(self.gamma))
        while (len(init_nodes) > 0):
            edge = power_law(xmin=1, xmax=self.gamma).rvs(size=1)[0]
            targets = []
            while (len(targets) < edge and len(init_nodes) > 0):
                x = random.choice(init_nodes)
                targets.append(x)
                init_nodes.remove(x)

            for pair in list(zip([self.source] * edge, targets)):
                if pair[0] != pair[1]:
                    self.neighbours.get(pair[0]).append(pair[1])
                    self.neighbours.get(pair[1]).append(pair[0])
                    self.E.append(pair)
            self.connected_nodes.extend(targets)
            self.connected_nodes.extend([self.source] * len(targets))
            self.source += 1

    def _createPair(self, nodes):
        u"""Generate an isolated pair in the graph, not connected
            to other components.
            :param nodes: a single node of class GraphNode
        """
        if self.copy:
            return
        self.neighbours.get(nodes[0]).append(nodes[1])
        self.neighbours.get(nodes[1]).append(nodes[0])
        self.E.append((nodes[0], nodes[1]))
        self.connected_nodes.extend(nodes)
        self.source +=2

    def _createNet(self, nodes):
        u"""Generate an isolated full connected small graph using
            BA model.
            :param nodes: nodes list to be created.
        """
        if self.copy:
            return
        self.source += len(nodes)
        while (len(nodes) > 0) and self.source < self.V[-1] + 1:
            edge = power_law(xmin=1, xmax=len(nodes)).rvs(size=1)[0]
            targets = []
            while (len(targets) < edge and len(nodes) > 0):
                x = random.choice(nodes)
                targets.append(x)
                nodes.remove(x)
            for pair in list(zip([self.source] * edge, targets)):
                if pair[0] != pair[1]:
                    self.neighbours.get(pair[0]).append(pair[1])
                    self.neighbours.get(pair[1]).append(pair[0])
                    self.E.append(pair)
            self.connected_nodes.extend(targets)
            self.connected_nodes.extend([self.source] * len(targets))
            self.source += 1

    def _createEdges(self, edge_num):
        u"""Add new edges to a graph using BA model following a power-law
            rule of edge degrees for every node.
            :param edge_num: the max number of edges in the graph.
        """
        if self.copy:
            return
        while self.source < self.V[-1] + 1 and len(self.E) <= edge_num:
            # print("current of source", self.source)
            iso = power_law(xmin=1, xmax=self.gamma).rvs(size=1)[0]
            if self.source + iso > self.V[-1] + 1:
                self.isolated_nodes.extend(list(range(self.source, self.V[-1] + 1)))
                self.source = self.V[-1] + 1
                break
            elif iso == 1:
                self.isolated_nodes.append(self.source)
                self.source += 1
                continue
            elif iso == 2:
                self._createPair([self.source, self.source + 1])
                continue
            elif iso < self.gamma:
                self._createNet(list(range(self.source, self.source + iso)))
                continue

            # Add Edges to main framework
            edge = power_law(xmin=1, xmax=self.gamma).rvs(size=1)[0]
            targets = set()
            while len(targets) < edge:
                x = random.choice(self.connected_nodes)
                targets.add(x)
            for pair in list(zip([self.source] * edge, targets)):
                if pair[0] != pair[1]:
                    self.neighbours.get(pair[0]).append(pair[1])
                    self.neighbours.get(pair[1]).append(pair[0])
                    self.E.append(pair)
            self.connected_nodes.extend(targets)
            self.connected_nodes.extend([self.source] * edge)
            self.source += 1

    def _dfsearch_recursive(self, node):
        u"""A recursive way using dfs algorithm to search nodes by
            their neighbours to return the connected list.
            :param node: the node started searching by dfs.
        """
        self.visited[node] = 1
        self.temp_component.append(node)
        for neighbour in self.neighbours[node]:
            if self.visited[neighbour] == 0:
                self._dfsearch(neighbour)

    def _dfs_non_recursive(self, nodes):
        u"""A None recursive way using dfs algorithm to search neighbours
            and return a full connected list.
            :param nodes: the node list that are searched by dfs.
        """
        visited = {}
        for v in nodes:
            visited[v] = False
        cluster = []
        end_of_scan = nodes[0]
        for v in nodes:
            if not any(x != True for x in visited.values()) and cluster:
                cluster.append(end_of_scan)
                self.connected_components.append(cluster)
                break
            if not visited[v]:
                yield v
                visited[v] = True
                stack = [(v, iter(self.neighbours[v]))]
                if v != end_of_scan and cluster:
                    cluster.append(end_of_scan)
                    self.connected_components.append(cluster)
                    end_of_scan = 0
                    cluster = []
                while stack:
                    _, neighbourlist = stack[-1]
                    try:
                        neighbour = next(neighbourlist)
                        if not visited[neighbour]:
                            yield neighbour
                            visited[neighbour] = True
                            stack.append((neighbour, iter(self.neighbours[neighbour])))
                            cluster.append(neighbour)
                    except StopIteration:
                        end_of_scan = v
                        stack.pop()

    def updateComponents(self):
        u"""Generate a list of all connected components using a
            None recursive dfs algorithm from all edges pairs
            :param None
        """
        self.connected_components = []
        for x in self._dfs_non_recursive(self.V):
            print("visited", x)

        ##############################################
        # Recursive way fails at big data >= 200K nodes
        ##############################################
        #for left, right in self.E:
        #    self.temp_component = []
        #    if self.visited[left] == 0:
        #        self._dfsearch(left)
        #    if len(self.temp_component) > 0:
        #        self.connected_components.append(self.temp_component)

    def getComponents(self):
        u"""Get a full list of all connected components.
            :param None
        """
        return self.connected_components

    def addDynamic(self, node_num, edge_num):
        u"""Add new nodes list to an exiting graph in a dynamic way
            :param node_num: the number of newly added nodes.
            :param edge_num: the max number of newly added edges.
        """
        nodes = list(range(self.V[-1] + 1, self.V[-1] + 1 + node_num))
        for v in nodes:
            self.V.append(v)
            self.neighbours[v] = []
        for v in self.V:
            self.visited[v] = 0
        self.source += 1
        self._createEdges(len(self.E) + edge_num)
        self.updateComponents()

    def addNodesFrom(self, nodes):
        u"""Add nodes from scrach to create graph from a node list.
            :param nodes: the nodes list to be created in the graph
        """
        if not self.copy:
            return
        for v in nodes:
            self.V.append(v)
            self.neighbours[v] = []
            self.visited[v] = 0

    def addEdgesFrom(self, edges):
        u"""Add edges from scrach to create graph from an edge list.
            :param edges: the edges list to be created in the graph
        """
        if not self.copy:
            return
        for pair in edges:
            if pair[0] != pair[1]:
                self.neighbours.get(pair[0]).append(pair[1])
                self.neighbours.get(pair[1]).append(pair[0])
                self.E.append(pair)
            self.connected_nodes.append(pair[0])
            self.connected_nodes.append(pair[1])

    def delNodesFrom(self, nodes):
        u"""Delete nodes from an exiting graph in a dynamic way.
            :param nodes: the nodes list to be deleted from the graph
        """
        for v in [value for value in nodes if value in self.V]:
            self.V.remove(v)
            self.connected_nodes[:] = (value for value in self.connected_nodes if value != v)
            self.isolated_nodes[:] = (value for value in self.isolated_nodes if value != v)
            for n in self.neighbours[v]:
                self.connected_nodes.remove(n)
                self.neighbours[n].remove(v)
                if (n, v) in self.E:
                    self.E.remove((n, v))
                else:
                    self.E.remove((v, n))
                self.neighbours[v] = []
        sorted_components = sorted(self.connected_components, key=len, reverse=True)
        p = set(nodes)
        for i, component in enumerate(sorted_components):
            s = set(component)
            if len(tuple(s & p)) > 0:
                self.connected_components.remove(component)
                component[:] = (value for value in component if value not in list(tuple(s & p)))
                if len(component) <= 1:
                    continue
                for x in self._dfs_non_recursive(component):
                    print("visited", x)
                p -= s
                if len(tuple(p)) == 0:
                    break

    def bfsearch(self, start_node):
        u"""A bfs algorithm to search all connected components from
            a start node. It returns all the visited noces and the edge
            degree.
            :param start_node: the node started searching by bfs.
        """
        queue = deque([start_node])
        visited_node = {}
        hop_away = 0
        while len(queue) != 0:
            label = queue.popleft()
            if label not in visited_node:
                visited_node[label] = [len(self.neighbours[label]), hop_away]
                queue += [x for x in self.neighbours[label] if x not in visited_node.keys()]
                hop_away += 1
        return visited_node

if __name__ == '__main__':

    from datetime import datetime

    import networkx as nx
    import matplotlib.pyplot as plt
    from networkx.drawing.nx_agraph import graphviz_layout

    start = datetime.now()
    bn = ProbGraph(node_num=2000, edge_num=20000, gamma=3)
    print("Time used for graph generation: ", datetime.now() - start)

    edge_degrees = []
    for v in bn.neighbours:
        edge_degrees.append(len(bn.neighbours[v]))
    plt.hist(edge_degrees, normed=True, bins=200)
    plt.ylabel('Probability of edge degree of all nodes')
    plt.show()

    component_size = []
    for v in bn.getComponents():
        component_size.append(len(v))
    print("cluser_size", sorted(component_size))
    plt.hist(component_size, normed=True, bins=200)
    plt.ylabel('Probability of size of connected components')
    plt.show()

